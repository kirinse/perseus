{"content":"<header data-hk=\"1.1\" class=\"shadow-md sm:p-2 w-full bg-white dark:text-white dark:bg-navy mb-20\"><div data-hk=\"1.2\" class=\"flex justify-between\"><a data-hk=\"1.3\" class=\"justify-self-start self-center m-3 ml-5 text-md sm:text-2xl\" href=\"en-US/\">Perseus</a><div data-hk=\"1.4\" class=\"md:hidden m-3 mr-5 tham tham-e-spin tham-w-6 \"><div data-hk=\"1.5\" class=\"tham-box\"><div data-hk=\"1.6\" class=\"dark:bg-white tham-inner\"></div></div></div><nav data-hk=\"1.7\" class=\"hidden md:flex\"><ul data-hk=\"1.8\" class=\"mr-5 flex\"><li data-hk=\"2.0\" class=\"m-3 p-1\"><a data-hk=\"2.1\" href=\"en-US/docs\" class=\"px-2\">Docs</a></li><li data-hk=\"2.2\" class=\"m-3 p-1\"><a data-hk=\"2.3\" href=\"en-US/comparisons\" class=\"px-2\">Comparisons</a></li><li data-hk=\"2.4\" class=\"m-3 p-1\"><a data-hk=\"2.5\" href=\"en-US/plugins\" class=\"px-2\">Plugins</a></li></ul></nav></div><nav data-hk=\"1.9\" id=\"mobile_nav_menu\" class=\"md:hidden w-full text-center justify-center overflow-y-scroll hidden\"><div data-hk=\"1.10\" class=\"mr-5 overflow-y-scroll\" style=\"max-height: 500px\"><ul data-hk=\"1.11\"><li data-hk=\"3.0\" class=\"m-3 p-1\"><a data-hk=\"3.1\" href=\"en-US/docs\" class=\"px-2\">Docs</a></li><li data-hk=\"3.2\" class=\"m-3 p-1\"><a data-hk=\"3.3\" href=\"en-US/comparisons\" class=\"px-2\">Comparisons</a></li><li data-hk=\"3.4\" class=\"m-3 p-1\"><a data-hk=\"3.5\" href=\"en-US/plugins\" class=\"px-2\">Plugins</a></li></ul><hr data-hk=\"1.12\"/><div data-hk=\"1.13\" class=\"text-left p-3\"><!--#--><!----><select data-hk=\"4.4\" class=\"p-2 rounded-md text-white bg-indigo-500\"><option data-hk=\"4.5\" value=\"next\">Next (unreleased)</option><option data-hk=\"4.0\" value=\"0.4.x\" selected=\"\">v⁨0.4.x⁩ (beta)</option><option data-hk=\"4.6\" value=\"0.3.4\">v⁨0.3.4⁩ (stable)</option><option data-hk=\"4.1\" value=\"0.3.0-0.3.3\">v⁨0.3.0-0.3.3⁩ (outdated)</option><option data-hk=\"4.2\" value=\"0.2.x\">v⁨0.2.x⁩ (outdated)</option><option data-hk=\"4.3\" value=\"0.1.x\">v⁨0.1.x⁩ (outdated)</option></select><!--/--><div data-hk=\"1.14\" class=\"docs-links-markdown\"><h1>Introduction</h1>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/intro\">Introduction</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/intro\">Getting Started</a>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/installation\">Installation</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/first-app\">Your First App</a></li>\n</ul>\n</li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/core-principles\">Core Principles</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/tutorials/second-app\">Your Second App</a></li>\n</ul>\n<h1>Reference</h1>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/features\">Feature Discovery Terminal</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/compilation-times\">Improving Compilation Times</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/state-generation\">State Generation</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/live-reloading-and-hsr\">Live Reloading and HSR</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/i18n\">Internationalization</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/hydration\">Hydration</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/exporting\">Static Exporting</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/plugins\">Plugins</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/deploying\">Deploying</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/architecture\">Architecture Details</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/router\">Router</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/initial_subsequent_loads\">Initial vs. Subsequent Loads</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/faq\">Common Pitfalls and Known Bugs</a></li>\n</ul>\n</div></div></div></nav></header><div data-hk=\"1.15\" class=\"mt-14 xs:mt-16 sm:mt-20 lg:mt-25 overflow-y-auto flex\"><div data-hk=\"1.16\" class=\"flex w-full\"><div data-hk=\"1.17\" class=\"h-full hidden md:block max-w-xs w-full border-r\"><div data-hk=\"1.18\" class=\"mr-5\"><div data-hk=\"1.19\" class=\"text-left text-black dark:text-white p-3\"><aside data-hk=\"1.20\"><!--#--><!----><select data-hk=\"5.4\" class=\"p-2 rounded-md text-white bg-indigo-500\"><option data-hk=\"5.5\" value=\"next\">Next (unreleased)</option><option data-hk=\"5.0\" value=\"0.4.x\" selected=\"\">v⁨0.4.x⁩ (beta)</option><option data-hk=\"5.6\" value=\"0.3.4\">v⁨0.3.4⁩ (stable)</option><option data-hk=\"5.1\" value=\"0.3.0-0.3.3\">v⁨0.3.0-0.3.3⁩ (outdated)</option><option data-hk=\"5.2\" value=\"0.2.x\">v⁨0.2.x⁩ (outdated)</option><option data-hk=\"5.3\" value=\"0.1.x\">v⁨0.1.x⁩ (outdated)</option></select><!--/--><div data-hk=\"1.21\" class=\"docs-links-markdown\"><h1>Introduction</h1>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/intro\">Introduction</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/intro\">Getting Started</a>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/installation\">Installation</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/first-app\">Your First App</a></li>\n</ul>\n</li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/core-principles\">Core Principles</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/tutorials/second-app\">Your Second App</a></li>\n</ul>\n<h1>Reference</h1>\n<ul>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/features\">Feature Discovery Terminal</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/compilation-times\">Improving Compilation Times</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/state-generation\">State Generation</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/live-reloading-and-hsr\">Live Reloading and HSR</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/i18n\">Internationalization</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/hydration\">Hydration</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/exporting\">Static Exporting</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/plugins\">Plugins</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/deploying\">Deploying</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/architecture\">Architecture Details</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/router\">Router</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/initial_subsequent_loads\">Initial vs. Subsequent Loads</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/faq\">Common Pitfalls and Known Bugs</a></li>\n</ul>\n</div></aside></div></div></div><div data-hk=\"1.22\" class=\"h-full flex w-full\"><div data-hk=\"1.23\" class=\"px-3 w-full sm:mr-auto sm:ml-auto sm:max-w-prose lg:max-w-3xl xl:max-w-4xl 2xl:max-w-5xl\"><!--#--><div data-hk=\"1.24\" class=\"ring-4 ring-yellow-300 p-4 rounded-lg mt-1\"><div data-hk=\"1.25\" class=\"flex flex-col 2xs:flex-row dark:text-white\"><span data-hk=\"1.26\" class=\"self-center mr-2\" style=\"fill: #fcd34d;\"><svg xmlns=\"http://www.w3.org/2000/svg\" height=\"auto\" viewBox=\"0 0 24 24\" width=\"2.25rem\" fill=\"\\#000000\"><path d=\"M12 5.99L19.53 19H4.47L12 5.99M2.74 18c-.77 1.33.19 3 1.73 3h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18zM11 11v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zm0 5h2v2h-2z\"/></svg></span><p data-hk=\"1.27\">This version of the documentation is for a version that has only been released in beta, and is not yet stable. Features documented here may not be present in the latest stable version, and they're subject to rapid and drastic change. You can see the latest stable version of the docs <a href=\"en-US/docs/0.3.4/intro\" class=\"underline\">here</a>.</p></div></div><!--/--><main data-hk=\"1.28\" class=\"text-black dark:text-white\"><div data-hk=\"1.0\" class=\"markdown\"><h1>State Generation</h1>\n<p>One of the most important features of Perseus is its state platform, as explained <a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/core-principles\">here</a>. However, for state to be of any use, you need a way to generate it. Perseus supports <em>many</em> ways of doing this: at build-time, at request-time, or several mixes of the two. This page will outline each of the possible state generation strategies.</p>\n<h2>Build State</h2>\n<p>The <em>build state</em> strategy is very simple: provide a function to a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a> and it will be run when you build your app. Its output will then be used as state!</p>\n<p>To take a simple example, let's say you have a (very contrived) page that should display the number of entries in a database at the time it was built. You would make a templat for this, perhaps called <code>entries</code> (so it would be hosted at <code>/entries</code> on your site), and you'd provide a simple view that calls on some state, which would only need a single property for the number of entries in the DB. Then, just show that!</p>\n<p>To make this work though, we need to execute some logic at build-time, which we can do with <em>build state</em>! By calling the <code>.build_state_fn()</code> method on <a href=\"struct.Template@perseus\"><code>Template</code></a> and providing a function annotated with <code>#[perseus::build_state]</code>, that function will be called when the template is built, and its output will be used to provide the initial value of the state.</p>\n<p>We should clarify at this point that the 'initial value' of the state is what's generated <em>before</em> it arrives in the browser. Then, it can be changed in the browser (e.g. a default value for an input generated at build-time that the user can change by typing in it), but any such changes will only impact that single browser. Changing the future value of the state involves <em>revalidation</em>, described below.</p>\n<p>A <em>build state</em> function takes two parameters: the path (see below) and the locale it's being built for. (You might use the locale if you're working with <a href=\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/i18n\">i18n</a> to fetch some language-specific data.) It will then return a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\n<h2>Build Paths</h2>\n<p>But now, let's say we actually have multiple tables in our database, and we want to know how many entries are in each one, with each count being displayed on a different page. Really, we want several pages under that <code>/entries</code> path now. This is easily achievable with <em>build paths</em>, which allows a single template to generate many pages.</p>\n<p>By providing a function to the <code>.build_paths_fn()</code> method of <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a>, that will be called at build-time to generate a <code>Vec&lt;String&gt;</code> of paths underneath <code>/entries</code>. For instant, if we returned <code>vec![ &quot;foo&quot;.to_string(), &quot;bar&quot;.to_string(), &quot;baz&quot;.to_string() ]</code>, Perseus would create pages at <code>/entries/foo</code>, <code>/entires/bar</code>, and <code>/entries/baz</code>. If you wanted to create an <code>/entries</code> page, you would provide an empty string as one of the elemtents in that <code>Vec&lt;String&gt;</code>.</p>\n<p>Note that you can also create nested paths like <code>foo/bar/baz</code> just like that.</p>\n<p>So, in our example, we would query our database for each of its tables, and then return a vector off their names, and Perseus would then generate a page for each, all from that same template!</p>\n<p>However, this is absolutely pointless without <em>build state</em> as well, since each of those pages would be the same right now. Usefully, as you may have noticed, the <em>build state</em> function takes its first parameter as the path, which is designed for working with <em>build paths</em>! So, in this case, of <code>foo</code>, <code>bar</code>, and <code>baz</code>, the provided <em>build state</em> function would be run three times, once with <code>entries/foo</code>, then with <code>entries/bar</code>, and finally with <code>entries/baz</code>. Notably, these runs will happen concurrently, speeding everything up! You can then use that given path to know which table's entry count to check. By making your <em>build state</em> function 'generic' in this way over the path it's given, which is representative here of the database table to fetch a count from, you can easily display many pages with different information, all from the same template!</p>\n<p>A <em>build paths</em> function takes no arguments, and returns a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResult.html\"><code>RenderFnResult&lt;Vec&lt;String&gt;&gt;</code></a>.</p>\n<h2>Request State</h2>\n<p>However, what if we only wanted to show the counts to certain people? Let's say authorized users will have a cookie in their browser that we can check somehow, and only they should be allowed to view these counts.</p>\n<p>We could use <em>request state</em> to run a function provided to the <code>.request_state_fn()</code> method of <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a> when a user's request comes in for that page. Unlike the build-time functions, the logic in here has to be very quick, otherwise we'll slow down the page load and reduce the performance of our site.</p>\n<p>Usefully, a <em>request state</em> function is given the <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Request.html\"><code>Request</code></a> from the user's request, which allows access to cookies, etc. With that, we can check if the user has our authentication cookie and make sure that it's valid, and then return a <code>None</code> for the count (which would now have to be an <code>Option&lt;u32&gt;</code>, see the next section) and <code>false</code> for a new <code>authorized</code> property.</p>\n<p>A <em>request state</em> function takes three arguments: the path, the locale it's being built for, and the user's request. It then returns a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\n<h2>Amalgamate States</h2>\n<p>However, there's a problem with the above idea in most frameworks that support build state and request state, or similar principles. You can only usually use one, since otherwise the build state and the request state might generate conflicting states! This is exactly what would happen here: the build state would happily get the count, and the request state would always override this as <code>None</code>, authorized or not, and it would set <code>authorized</code>, which the build state might always assume to be <code>true</code>. Whatever shall we do?</p>\n<p>The answer to this is dead simple: the <em>state amalgamation</em> strategy, whjich allows us to take in both of those states and do some arbitrary stuff to resolve them. In this case, based on the value of <code>authorized</code> property from the <em>request state</em>, we would either return <code>authorized: false, state: None</code>, or <code>authorized: true, state: Some(state)</code>, where <code>state</code> in the latter comes from the <em>build state</em> function. Nifty, eh?</p>\n<p>Note though that you won't always need state amalgamation, it's mostly useful for adding this kind of authentication to pages that already have build state, allowing you to get the best optimizations and the best security!</p>\n<p>A <em>state amalgamation</em> function takes four arguments: the path, the locale it's being built for, the build state, and the request state (both unreactive). It then returns a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\n<h2>Revalidation</h2>\n<p>Now, what if we wanted to make that count a little more up to date? Say, we should update it daily. Perseus makes this trivial, you just use the <code>.revalidate_after</code> method on <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a> to define an interval, and, every time a new request comes in, if more than that interval has elapsed, then the <em>build state</em> function will be re-run.</p>\n<p>Alternatively, you might want to perform some logic first to check if the state should be revalidated or not: use <code>.should_revalidate_fn()</code> on <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a> to provide the function that does this.</p>\n<p>Note that you can use both time-based <em>and</em> logic-based revalidation on the same template if you want to: the logic-based one will only run if the time-based one tells it to.</p>\n<p><em>Note: if you use revalidation on a template with many pages, revalidation will be performed piecemeal, page-by-page, as each is requested.</em></p>\n<p>A <em>logic-based revalidation</em> function (provided to <code>.should_revalidate.fn()</code>) takes three arguments: the path, the locale it's being built for, and the user's request. It then returns a <code>bool</code>. The reason the build-time/request-time states are not available is due to the structure of the internal render algorithms, and practicalities: anything needed from the request state can be re-derived from the user's request, and the build state can't be used for checking if a page should revalidate, since it's always going to be the same.</p>\n<h2>Incremental Generation</h2>\n<p>Finally, let's say your database is getting a little out of hand, with new tables popping up every other day. You don't want to constantly have to be rebuilding your whole app for each new table!</p>\n<p>In this case, you would want to call <code>.incremental_generation()</code> on <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\"><code>Template</code></a>, which opens the floodgates, so to speak! Essentially, if we still have our three pages from before (i.e. <code>/entries/foo</code>, <code>/entries/bar</code>, and <code>/entries/baz</code>), and the user goes to <code>/entries/test</code>, rather than sending a <em>404 Not Found</em> error, the Perseus server will run the <em>build state</em> function for this path (<code>entries/test</code>), and it will build for that database table at request-time! Even better, if this all works, it'll cache the results for next time, meaning it can serve <code>/entries/test</code> instantly next time!</p>\n<p>As you can imagine, this is <em>extremely</em> useful for templates that render millions, or even billions of pages, since you can build them dynamically and cache them for performance at runtime, rather than spending hours building all of them.</p>\n<p>And <em>this</em> is why you the <em>build state</em> function returns a <a href=\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\"><code>RenderFnResultWithCause</code></a>, because you can <em>blame</em> either the client or the server. Without incremental generation, you know you'll only get those paths you defined in the <em>build paths</em> function, but, with incremental generation, you could get anything. If you know there's one table, say <code>admin</code>, that you should never serve a count for, you can add an if-statement to the top of your <em>build state</em> function that checks if the <code>path</code> argument is <code>entries/admin</code>, and returns a <em>404 Not Found</em> error, blaming the client, and they'll be none the wiser!</p>\n<p><em>Note: in applications using both build paths and incremental generation, those paths defined by the build paths function will be rendered at build-time, while any more that aren't defined there will be rendered dynamically upon request.</em></p>\n<h2>Examples</h2>\n<p>Some of this may be a little tricky to visualize, so there's an example <a href=\"https://github.com/artic-hen7/perseus/tree/main/examples/core/state_generation\">here</a> that goes through each of Perseus' state generation strategies systemtically! Note that it doesn't use the same example of a database entry counter as described here, but rather more basic examples to just show the basic functionality of each strategy. Enjoy!</p>\n</div></main></div></div></div></div><footer data-hk=\"1.29\" class=\"w-full flex justify-center py-5 bg-gray-100 dark:bg-navy-deep\"><p data-hk=\"1.30\" class=\"dark:text-white mx-5 text-center\"><span data-hk=\"1.31\">© <a href=\"https://github.com/arctic-hen7\" class=\"underline\">arctic-hen7</a> ⁨2021⁩, see license <a href=\"https://github.com/arctic-hen7/perseus/blob/main/LICENSE\" class=\"underline\">here</a>.</span></p></footer><script data-hk=\"0.0\" src=\".perseus/static/prism.js\" defer=\"\"></script><script data-hk=\"0.1\">window.Prism.highlightAll();</script>","state":"{\"title\":\"State Generation\",\"content\":\"<h1>State Generation</h1>\\n<p>One of the most important features of Perseus is its state platform, as explained <a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/core-principles\\\">here</a>. However, for state to be of any use, you need a way to generate it. Perseus supports <em>many</em> ways of doing this: at build-time, at request-time, or several mixes of the two. This page will outline each of the possible state generation strategies.</p>\\n<h2>Build State</h2>\\n<p>The <em>build state</em> strategy is very simple: provide a function to a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a> and it will be run when you build your app. Its output will then be used as state!</p>\\n<p>To take a simple example, let's say you have a (very contrived) page that should display the number of entries in a database at the time it was built. You would make a templat for this, perhaps called <code>entries</code> (so it would be hosted at <code>/entries</code> on your site), and you'd provide a simple view that calls on some state, which would only need a single property for the number of entries in the DB. Then, just show that!</p>\\n<p>To make this work though, we need to execute some logic at build-time, which we can do with <em>build state</em>! By calling the <code>.build_state_fn()</code> method on <a href=\\\"struct.Template@perseus\\\"><code>Template</code></a> and providing a function annotated with <code>#[perseus::build_state]</code>, that function will be called when the template is built, and its output will be used to provide the initial value of the state.</p>\\n<p>We should clarify at this point that the 'initial value' of the state is what's generated <em>before</em> it arrives in the browser. Then, it can be changed in the browser (e.g. a default value for an input generated at build-time that the user can change by typing in it), but any such changes will only impact that single browser. Changing the future value of the state involves <em>revalidation</em>, described below.</p>\\n<p>A <em>build state</em> function takes two parameters: the path (see below) and the locale it's being built for. (You might use the locale if you're working with <a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/i18n\\\">i18n</a> to fetch some language-specific data.) It will then return a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\\\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\\n<h2>Build Paths</h2>\\n<p>But now, let's say we actually have multiple tables in our database, and we want to know how many entries are in each one, with each count being displayed on a different page. Really, we want several pages under that <code>/entries</code> path now. This is easily achievable with <em>build paths</em>, which allows a single template to generate many pages.</p>\\n<p>By providing a function to the <code>.build_paths_fn()</code> method of <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a>, that will be called at build-time to generate a <code>Vec&lt;String&gt;</code> of paths underneath <code>/entries</code>. For instant, if we returned <code>vec![ &quot;foo&quot;.to_string(), &quot;bar&quot;.to_string(), &quot;baz&quot;.to_string() ]</code>, Perseus would create pages at <code>/entries/foo</code>, <code>/entires/bar</code>, and <code>/entries/baz</code>. If you wanted to create an <code>/entries</code> page, you would provide an empty string as one of the elemtents in that <code>Vec&lt;String&gt;</code>.</p>\\n<p>Note that you can also create nested paths like <code>foo/bar/baz</code> just like that.</p>\\n<p>So, in our example, we would query our database for each of its tables, and then return a vector off their names, and Perseus would then generate a page for each, all from that same template!</p>\\n<p>However, this is absolutely pointless without <em>build state</em> as well, since each of those pages would be the same right now. Usefully, as you may have noticed, the <em>build state</em> function takes its first parameter as the path, which is designed for working with <em>build paths</em>! So, in this case, of <code>foo</code>, <code>bar</code>, and <code>baz</code>, the provided <em>build state</em> function would be run three times, once with <code>entries/foo</code>, then with <code>entries/bar</code>, and finally with <code>entries/baz</code>. Notably, these runs will happen concurrently, speeding everything up! You can then use that given path to know which table's entry count to check. By making your <em>build state</em> function 'generic' in this way over the path it's given, which is representative here of the database table to fetch a count from, you can easily display many pages with different information, all from the same template!</p>\\n<p>A <em>build paths</em> function takes no arguments, and returns a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResult.html\\\"><code>RenderFnResult&lt;Vec&lt;String&gt;&gt;</code></a>.</p>\\n<h2>Request State</h2>\\n<p>However, what if we only wanted to show the counts to certain people? Let's say authorized users will have a cookie in their browser that we can check somehow, and only they should be allowed to view these counts.</p>\\n<p>We could use <em>request state</em> to run a function provided to the <code>.request_state_fn()</code> method of <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a> when a user's request comes in for that page. Unlike the build-time functions, the logic in here has to be very quick, otherwise we'll slow down the page load and reduce the performance of our site.</p>\\n<p>Usefully, a <em>request state</em> function is given the <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Request.html\\\"><code>Request</code></a> from the user's request, which allows access to cookies, etc. With that, we can check if the user has our authentication cookie and make sure that it's valid, and then return a <code>None</code> for the count (which would now have to be an <code>Option&lt;u32&gt;</code>, see the next section) and <code>false</code> for a new <code>authorized</code> property.</p>\\n<p>A <em>request state</em> function takes three arguments: the path, the locale it's being built for, and the user's request. It then returns a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\\\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\\n<h2>Amalgamate States</h2>\\n<p>However, there's a problem with the above idea in most frameworks that support build state and request state, or similar principles. You can only usually use one, since otherwise the build state and the request state might generate conflicting states! This is exactly what would happen here: the build state would happily get the count, and the request state would always override this as <code>None</code>, authorized or not, and it would set <code>authorized</code>, which the build state might always assume to be <code>true</code>. Whatever shall we do?</p>\\n<p>The answer to this is dead simple: the <em>state amalgamation</em> strategy, whjich allows us to take in both of those states and do some arbitrary stuff to resolve them. In this case, based on the value of <code>authorized</code> property from the <em>request state</em>, we would either return <code>authorized: false, state: None</code>, or <code>authorized: true, state: Some(state)</code>, where <code>state</code> in the latter comes from the <em>build state</em> function. Nifty, eh?</p>\\n<p>Note though that you won't always need state amalgamation, it's mostly useful for adding this kind of authentication to pages that already have build state, allowing you to get the best optimizations and the best security!</p>\\n<p>A <em>state amalgamation</em> function takes four arguments: the path, the locale it's being built for, the build state, and the request state (both unreactive). It then returns a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\\\"><code>RenderFnResultWithCause&lt;State&gt;</code></a>, where <code>State</code> is your state type.</p>\\n<h2>Revalidation</h2>\\n<p>Now, what if we wanted to make that count a little more up to date? Say, we should update it daily. Perseus makes this trivial, you just use the <code>.revalidate_after</code> method on <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a> to define an interval, and, every time a new request comes in, if more than that interval has elapsed, then the <em>build state</em> function will be re-run.</p>\\n<p>Alternatively, you might want to perform some logic first to check if the state should be revalidated or not: use <code>.should_revalidate_fn()</code> on <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a> to provide the function that does this.</p>\\n<p>Note that you can use both time-based <em>and</em> logic-based revalidation on the same template if you want to: the logic-based one will only run if the time-based one tells it to.</p>\\n<p><em>Note: if you use revalidation on a template with many pages, revalidation will be performed piecemeal, page-by-page, as each is requested.</em></p>\\n<p>A <em>logic-based revalidation</em> function (provided to <code>.should_revalidate.fn()</code>) takes three arguments: the path, the locale it's being built for, and the user's request. It then returns a <code>bool</code>. The reason the build-time/request-time states are not available is due to the structure of the internal render algorithms, and practicalities: anything needed from the request state can be re-derived from the user's request, and the build state can't be used for checking if a page should revalidate, since it's always going to be the same.</p>\\n<h2>Incremental Generation</h2>\\n<p>Finally, let's say your database is getting a little out of hand, with new tables popping up every other day. You don't want to constantly have to be rebuilding your whole app for each new table!</p>\\n<p>In this case, you would want to call <code>.incremental_generation()</code> on <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/struct.Template.html\\\"><code>Template</code></a>, which opens the floodgates, so to speak! Essentially, if we still have our three pages from before (i.e. <code>/entries/foo</code>, <code>/entries/bar</code>, and <code>/entries/baz</code>), and the user goes to <code>/entries/test</code>, rather than sending a <em>404 Not Found</em> error, the Perseus server will run the <em>build state</em> function for this path (<code>entries/test</code>), and it will build for that database table at request-time! Even better, if this all works, it'll cache the results for next time, meaning it can serve <code>/entries/test</code> instantly next time!</p>\\n<p>As you can imagine, this is <em>extremely</em> useful for templates that render millions, or even billions of pages, since you can build them dynamically and cache them for performance at runtime, rather than spending hours building all of them.</p>\\n<p>And <em>this</em> is why you the <em>build state</em> function returns a <a href=\\\"https://docs.rs/perseus/0.4.0-beta/perseus/type.RenderFnResultWithCause.html\\\"><code>RenderFnResultWithCause</code></a>, because you can <em>blame</em> either the client or the server. Without incremental generation, you know you'll only get those paths you defined in the <em>build paths</em> function, but, with incremental generation, you could get anything. If you know there's one table, say <code>admin</code>, that you should never serve a count for, you can add an if-statement to the top of your <em>build state</em> function that checks if the <code>path</code> argument is <code>entries/admin</code>, and returns a <em>404 Not Found</em> error, blaming the client, and they'll be none the wiser!</p>\\n<p><em>Note: in applications using both build paths and incremental generation, those paths defined by the build paths function will be rendered at build-time, while any more that aren't defined there will be rendered dynamically upon request.</em></p>\\n<h2>Examples</h2>\\n<p>Some of this may be a little tricky to visualize, so there's an example <a href=\\\"https://github.com/artic-hen7/perseus/tree/main/examples/core/state_generation\\\">here</a> that goes through each of Perseus' state generation strategies systemtically! Note that it doesn't use the same example of a database entry counter as described here, but rather more basic examples to just show the basic functionality of each strategy. Enjoy!</p>\\n\",\"sidebar_content\":\"<h1>Introduction</h1>\\n<ul>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/intro\\\">Introduction</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/what-is-perseus\\\">What is Perseus?</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/intro\\\">Getting Started</a>\\n<ul>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/installation\\\">Installation</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/getting-started/first-app\\\">Your First App</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/core-principles\\\">Core Principles</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/tutorials/second-app\\\">Your Second App</a></li>\\n</ul>\\n<h1>Reference</h1>\\n<ul>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/features\\\">Feature Discovery Terminal</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/compilation-times\\\">Improving Compilation Times</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/state-generation\\\">State Generation</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/live-reloading-and-hsr\\\">Live Reloading and HSR</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/i18n\\\">Internationalization</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/hydration\\\">Hydration</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/exporting\\\">Static Exporting</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/plugins\\\">Plugins</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/deploying\\\">Deploying</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/architecture\\\">Architecture Details</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/router\\\">Router</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/initial_subsequent_loads\\\">Initial vs. Subsequent Loads</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/migrating\\\">Migrating from v0.3.x</a></li>\\n<li><a href=\\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.4.x/reference/faq\\\">Common Pitfalls and Known Bugs</a></li>\\n</ul>\\n\",\"status\":\"Beta\",\"manifest\":{\"0.2.x\":{\"state\":\"outdated\",\"git\":\"v0.2.3\",\"docs_rs\":\"0.2\"},\"0.1.x\":{\"state\":\"outdated\",\"git\":\"v0.1.4\",\"docs_rs\":\"0.1\"},\"0.3.0-0.3.3\":{\"state\":\"outdated\",\"git\":\"v0.3.3\",\"docs_rs\":\"0.3.3\"},\"0.3.4\":{\"state\":\"stable\",\"git\":\"eccf137032fbe8e6507be9e9317edc16e7576a4f\",\"docs_rs\":\"0.3\"},\"0.4.x\":{\"state\":\"beta\",\"git\":\"HEAD\",\"docs_rs\":\"0.4.0-beta\"}},\"current_version\":\"0.4.x\"}","head":"<title>State Generation | Perseus Docs</title><link rel=\"stylesheet\" href=\".perseus/static/styles/markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/styles/docs_links_markdown.css\"/><link rel=\"stylesheet\" href=\".perseus/static/prism.css\"/>"}