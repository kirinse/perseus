<!DOCTYPE html>
<html  class="light"><head><base href="https://arctic-hen7.github.io/perseus/" />
<meta  charset="UTF-8"/><meta  name="viewport" content="width=device-width, initial-scale=1.0"/><link  rel="stylesheet" href=".perseus/static/tailwind.css"/><link  rel="stylesheet" href=".perseus/static/styles/style.css"/>
            <script type="module">window.__PERSEUS_RENDER_CFG = '{"docs/next/tutorials/second-app":"docs","docs/0.1.x/building":"docs","docs/0.3.4/advanced/initial-loads":"docs","docs/0.4.x/reference/router":"docs","docs/next/reference/live-reloading-and-hsr":"docs","docs/reference/deploying/intro":"docs","docs/0.3.0-0.3.3/i18n/intro":"docs","docs/0.3.4/reference/templates/metadata-modification":"docs","docs/0.2.x/ejecting":"docs","docs/reference/ejecting":"docs","docs/0.1.x/templates":"docs","docs/0.3.0-0.3.3/static-content":"docs","docs/0.1.x/cli":"docs","docs/0.3.0-0.3.3/hello-world":"docs","docs/0.3.0-0.3.3/updating":"docs","docs/reference/templates/intro":"docs","docs/0.3.4/reference/strategies/build-state":"docs","docs/0.3.4/reference/deploying/intro":"docs","docs/reference/state/global":"docs","docs/0.3.4/reference/i18n/translations-managers":"docs","docs/0.1.x/strategies/incremental":"docs","docs/0.1.x/tutorials/first_app/app":"docs","docs/0.1.x/intro":"docs","docs/0.3.0-0.3.3/plugins/writing":"docs","docs/reference/strategies/build-state":"docs","docs/0.3.0-0.3.3/plugins/publishing":"docs","docs/0.3.0-0.3.3/exporting":"docs","docs/0.3.4/reference/deploying/serverless":"docs","docs/reference/cli":"docs","docs/0.3.0-0.3.3/strategies/request-state":"docs","docs/0.3.0-0.3.3/snooping":"docs","docs/reference/deploying/size":"docs","docs/0.3.0-0.3.3/server-communication":"docs","docs/0.3.4/advanced/intro":"docs","docs/0.3.4/what-is-perseus":"docs","docs/0.2.x/testing/fantoccini-basics":"docs","docs/0.3.0-0.3.3/templates/metadata-modification":"docs","docs/0.4.x/reference/i18n":"docs","docs/reference/hydration":"docs","docs/next/reference/faq":"docs","docs/0.3.0-0.3.3/second-app":"docs","docs/0.2.x/second-app":"docs","docs/0.1.x/serving":"docs","docs/reference/debugging":"docs","docs/tutorials/second-app":"docs","docs/0.2.x/strategies/revalidation":"docs","docs/reference/i18n/intro":"docs","docs/0.3.4/reference/strategies/amalgamation":"docs","docs/0.3.0-0.3.3/deploying/relative-paths":"docs","docs/0.3.4/reference/strategies/intro":"docs","docs/reference/deploying/serverless":"docs","docs/reference/strategies/amalgamation":"docs","docs/next/getting-started/intro":"docs","docs/0.4.x/intro":"docs","docs/0.4.x/reference/compilation-times":"docs","docs/0.3.0-0.3.3/debugging":"docs","docs/0.3.4/reference/deploying/size":"docs","docs/0.1.x/strategies/revalidation":"docs","docs/next/reference/architecture":"docs","docs/0.3.4/reference/stores":"docs","docs/0.3.4/reference/testing/intro":"docs","docs/0.1.x/tutorials/first_app/setup":"docs","docs/next/reference/hydration":"docs","docs/0.1.x/tutorials/first_app/intro":"docs","docs/0.3.4/reference/strategies/incremental":"docs","docs/reference/stores":"docs","docs/0.2.x/i18n/other-engines":"docs","docs/reference/plugins/intro":"docs","docs/0.3.0-0.3.3/plugins/control":"docs","docs/0.4.x/reference/state-generation":"docs","docs/reference/testing/intro":"docs","docs/0.2.x/debugging":"docs","plugins":"plugins","docs/reference/plugins/using":"docs","docs/0.3.0-0.3.3/plugins/intro":"docs","docs/reference/state/hsr":"docs","docs/0.2.x/what-is-perseus":"docs","docs/0.3.0-0.3.3/strategies/revalidation":"docs","docs/next/reference/migrating":"docs","docs/0.3.4/reference/state/idb-freezing":"docs","docs/0.2.x/testing/checkpoints":"docs","docs/reference/plugins/tinker":"docs","docs/0.2.x/strategies/build-state":"docs","docs/0.3.0-0.3.3/plugins/security":"docs","docs/0.3.0-0.3.3/views":"docs","docs/0.2.x/deploying/exporting":"docs","docs/0.3.4/reference/templates/intro":"docs","docs/0.3.4/reference/i18n/using":"docs","docs/0.2.x/cli":"docs","docs/next/reference/deploying":"docs","docs/0.2.x/intro":"docs","docs/reference/state/freezing":"docs","docs/0.3.4/reference/deploying/relative-paths":"docs","docs/advanced/route-announcer":"docs","docs/0.3.4/reference/plugins/using":"docs","docs/0.2.x/i18n/defining":"docs","docs/0.3.4/reference/i18n/intro":"docs","docs/next/reference/exporting":"docs","docs/0.4.x/getting-started/intro":"docs","docs/advanced/initial-loads":"docs","docs/0.3.0-0.3.3/plugins/functional":"docs","docs/0.2.x/error-pages":"docs","docs/0.2.x/templates/intro":"docs","docs/0.3.4/reference/index-view":"docs","docs/0.3.4/reference/plugins/security":"docs","docs/0.3.0-0.3.3/advanced/subsequent-loads":"docs","docs/0.2.x/advanced/arch":"docs","docs/next/reference/state-generation":"docs","docs/0.3.4/reference/state/global":"docs","docs/0.4.x/reference/initial_subsequent_loads":"docs","docs/next/getting-started/installation":"docs","docs/0.2.x/config-managers":"docs","docs/0.3.4/reference/views":"docs","docs/0.3.4/advanced/routing":"docs","docs/0.3.0-0.3.3/advanced/intro":"docs","docs/0.3.4/reference/pitfalls-and-bugs":"docs","docs/advanced/subsequent-loads":"docs","docs/0.3.0-0.3.3/advanced/arch":"docs","docs/0.3.0-0.3.3/deploying/serverful":"docs","docs/0.3.4/reference/engines":"docs","docs/0.3.4/reference/ejecting":"docs","docs/0.3.4/reference/state/hsr":"docs","docs/0.3.0-0.3.3/testing/fantoccini-basics":"docs","docs/0.3.0-0.3.3/testing/manual":"docs","docs/reference/static-content":"docs","docs/0.4.x/getting-started/installation":"docs","docs/0.3.4/reference/static-content":"docs","docs/next/reference/router":"docs","docs/0.1.x/strategies/request_state":"docs","docs/reference/strategies/build-paths":"docs","docs/0.3.4/reference/templates/router-state":"docs","docs/0.4.x/core-principles":"docs","docs/0.3.4/core-principles":"docs","docs/intro":"docs","docs/next/reference/compilation-times":"docs","docs/0.3.0-0.3.3/strategies/build-paths":"docs","docs/0.2.x/i18n/using":"docs","docs/0.2.x/strategies/request-state":"docs","docs":"docs","docs/0.2.x/strategies/build-paths":"docs","docs/0.3.4/reference/strategies/request-state":"docs","docs/core-principles":"docs","docs/0.4.x/reference/exporting":"docs","docs/reference/deploying/docker":"docs","docs/0.3.0-0.3.3/plugins/tinker":"docs","docs/0.3.0-0.3.3/templates/setting-headers":"docs","docs/next/features":"docs","docs/0.1.x/config_managers":"docs","docs/0.4.x/getting-started/first-app":"docs","docs/0.3.0-0.3.3/styling":"docs","docs/0.2.x/updating":"docs","docs/0.2.x/advanced/intro":"docs","docs/0.3.0-0.3.3/testing/checkpoints":"docs","docs/0.3.0-0.3.3/i18n/other-engines":"docs","docs/0.3.0-0.3.3/i18n/using":"docs","docs/0.2.x/deploying/intro":"docs","docs/0.3.0-0.3.3/stores":"docs","docs/reference/plugins/security":"docs","docs/reference/strategies/request-state":"docs","docs/reference/exporting":"docs","docs/advanced/routing":"docs","docs/0.3.4/reference/plugins/control":"docs","index":"index","docs/reference/testing/fantoccini-basics":"docs","docs/reference/i18n/other-engines":"docs","docs/0.1.x/strategies/intro":"docs","docs/reference/plugins/functional":"docs","docs/0.2.x/advanced/routing":"docs","docs/0.3.0-0.3.3/advanced/initial-loads":"docs","comparisons":"comparisons","docs/0.3.0-0.3.3/strategies/intro":"docs","docs/reference/error-pages":"docs","docs/0.3.4/reference/testing/fantoccini-basics":"docs","docs/0.3.4/reference/cli":"docs","docs/0.4.x/reference/deploying":"docs","docs/0.2.x/i18n/intro":"docs","docs/0.3.0-0.3.3/ejecting":"docs","docs/0.3.4/reference/plugins/publishing":"docs","docs/0.3.4/reference/debugging":"docs","docs/0.3.0-0.3.3/testing/intro":"docs","docs/0.3.4/reference/server-communication":"docs","docs/0.3.0-0.3.3/deploying/size":"docs","docs/reference/templates/setting-headers":"docs","docs/0.2.x/testing/manual":"docs","docs/reference/deploying/relative-paths":"docs","docs/0.3.0-0.3.3/plugins/using":"docs","docs/0.3.4/reference/plugins/writing":"docs","docs/0.3.4/reference/styling":"docs","docs/reference/i18n/defining":"docs","docs/0.3.0-0.3.3/strategies/amalgamation":"docs","docs/0.3.0-0.3.3/pitfalls-and-bugs":"docs","docs/reference/updating":"docs","docs/0.3.4/reference/testing/checkpoints":"docs","docs/0.3.0-0.3.3/define-app":"docs","docs/advanced/intro":"docs","docs/reference/plugins/control":"docs","docs/next/reference/initial_subsequent_loads":"docs","docs/0.4.x/what-is-perseus":"docs","docs/next/reference/i18n":"docs","docs/reference/templates/router-state":"docs","docs/0.4.x/reference/live-reloading-and-hsr":"docs","docs/0.3.0-0.3.3/what-is-perseus":"docs","docs/reference/plugins/publishing":"docs","docs/0.3.4/reference/plugins/tinker":"docs","docs/reference/define-app":"docs","docs/0.2.x/strategies/intro":"docs","docs/0.3.4/reference/templates/setting-headers":"docs","docs/0.1.x/arch":"docs","docs/0.2.x/static-content":"docs","docs/0.2.x/views":"docs","docs/0.2.x/advanced/subsequent-loads":"docs","docs/0.3.4/reference/state/freezing":"docs","docs/0.3.4/advanced/arch":"docs","docs/0.3.4/reference/define-app":"docs","docs/0.1.x/strategies/build_paths":"docs","docs/reference/i18n/translations-managers":"docs","docs/reference/snooping":"docs","docs/reference/strategies/intro":"docs","docs/0.3.0-0.3.3/error-pages":"docs","docs/reference/state/rx":"docs","docs/0.3.4/reference/i18n/defining":"docs","docs/0.4.x/features":"docs","docs/0.4.x/reference/hydration":"docs","docs/reference/views":"docs","docs/0.3.0-0.3.3/i18n/defining":"docs","docs/0.4.x/reference/architecture":"docs","docs/0.3.0-0.3.3/hydration":"docs","docs/0.1.x/tutorials/first_app/template":"docs","docs/reference/testing/checkpoints":"docs","docs/0.2.x/styling":"docs","docs/0.2.x/strategies/incremental":"docs","docs/0.3.0-0.3.3/intro":"docs","docs/next/reference/plugins":"docs","docs/0.1.x/routing":"docs","docs/0.4.x/reference/plugins":"docs","docs/0.2.x/strategies/amalgamation":"docs","docs/next/core-principles":"docs","docs/0.3.4/reference/live-reloading":"docs","docs/0.3.4/reference/error-pages":"docs","docs/0.3.4/reference/plugins/intro":"docs","docs/next/what-is-perseus":"docs","docs/0.3.0-0.3.3/deploying/serverless":"docs","docs/reference/deploying/serverful":"docs","docs/next/intro":"docs","docs/0.4.x/reference/migrating":"docs","docs/0.3.4/advanced/subsequent-loads":"docs","docs/0.2.x/advanced/initial-loads":"docs","docs/0.2.x/testing/intro":"docs","docs/0.3.0-0.3.3/advanced/define_app":"docs","docs/0.4.x/reference/faq":"docs","docs/0.3.4/reference/snooping":"docs","docs/0.2.x/i18n/translations-managers":"docs","docs/0.3.4/reference/deploying/serverful":"docs","docs/0.3.4/reference/perseus-app":"docs","docs/0.3.4/intro":"docs","docs/0.3.0-0.3.3/strategies/build-state":"docs","docs/0.3.4/reference/state/rx":"docs","docs/0.3.4/reference/i18n/other-engines":"docs","docs/0.3.4/reference/testing/manual":"docs","docs/advanced/arch":"docs","docs/0.3.0-0.3.3/deploying/docker":"docs","docs/reference/i18n/using":"docs","docs/reference/styling":"docs","docs/0.3.0-0.3.3/cli":"docs","docs/reference/templates/metadata-modification":"docs","docs/next/getting-started/first-app":"docs","docs/0.3.4/reference/exporting":"docs","docs/0.3.0-0.3.3/i18n/translations-managers":"docs","docs/0.3.4/tutorials/hello-world":"docs","docs/0.1.x/integrations/actix-web":"docs","docs/reference/state/idb-freezing":"docs","docs/0.2.x/define-app":"docs","docs/0.1.x/error_pages":"docs","docs/0.3.0-0.3.3/deploying/intro":"docs","docs/0.3.4/advanced/route-announcer":"docs","docs/reference/perseus-app":"docs","docs/0.3.4/reference/hydration":"docs","docs/0.3.4/reference/deploying/docker":"docs","docs/0.3.4/tutorials/auth":"docs","docs/reference/live-reloading":"docs","docs/0.3.4/reference/strategies/revalidation":"docs","docs/0.2.x/templates/metadata-modification":"docs","docs/0.2.x/hello-world":"docs","docs/0.3.4/reference/strategies/build-paths":"docs","docs/0.2.x/templates/setting-headers":"docs","docs/tutorials/hello-world":"docs","docs/reference/strategies/incremental":"docs","docs/0.3.0-0.3.3/templates/intro":"docs","docs/0.3.4/reference/plugins/functional":"docs","docs/0.1.x/setup":"docs","docs/reference/pitfalls-and-bugs":"docs","docs/0.1.x/strategies/build_state":"docs","docs/reference/strategies/revalidation":"docs","docs/reference/engines":"docs","docs/0.3.4/reference/updating":"docs","docs/reference/plugins/writing":"docs","docs/tutorials/auth":"docs","docs/what-is-perseus":"docs","docs/reference/server-communication":"docs","docs/0.3.4/tutorials/second-app":"docs","docs/reference/testing/manual":"docs","docs/reference/index-view":"docs","docs/0.3.0-0.3.3/strategies/incremental":"docs","docs/0.4.x/tutorials/second-app":"docs","docs/0.3.0-0.3.3/advanced/routing":"docs"}';

        import init from "https://arctic-hen7.github.io/perseus/.perseus/bundle.js";
        async function main() {
            await init("https://arctic-hen7.github.io/perseus/.perseus/bundle.wasm");
        }
        main();
        

window.__PERSEUS_GLOBAL_STATE = `None`;</script>
            <!--PERSEUS_INTERPOLATED_HEAD_BEGINS-->
            
<title>Authentication | Perseus Docs</title><link rel="stylesheet" href=".perseus/static/styles/markdown.css"/><link rel="stylesheet" href=".perseus/static/styles/docs_links_markdown.css"/><link rel="stylesheet" href=".perseus/static/prism.css"/>
            <script>
window.__PERSEUS_INITIAL_STATE = `{"title":"Authentication","content":"<h1>Authentication</h1>\\n<p>If you're building an app with multiple users that might have different preferences or the like, chances are you'll need some way for those users to log in, you'll need an authentication system. This is fairly easy to achieve in Perseus with the <a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global\\">global state</a> system, though there are a few gotchas -- hence this tutorial!</p>\\n<h2>Concepts</h2>\\n<p>Authentication as a process involves the user wanting to go to some page that they need to be logged in to access (e.g. a dashboard of bank statements), logging in, accessing that page, and then maybe logging back out a little later. All that really boils down to in terms of code is a system to manage whether or not the user is logged in, a system of authenticating the user's password (or however else they're logging in), and a system of providing access on certain pages only to authenticated users.</p>\\n<p>The first part can be achieved through an entry in an app's global state that describes whether or not the user is logged in, what their username is, etc. Notably, this could be saved through <a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/freezing\\">state freezing</a> to IndexedDB (which would preserve all the properties of the user's login) (not covered in this tutorial), though we still need a way of securely confirming that the user is who they say they are. For that, we would need to store a token, often done in the browser's <a href=\\"TODO\\">local storage</a> API, which we'll use in this example. As for how this token works, that requires a good deal of thought to security and how your app will work, and so is elided here (we'll just use a very insecure 'token' that tells us what the user's username is).</p>\\n<p>The final part of this is controlling access to protected pages, which is the part where Perseus becomes more relevant as a framework. There are two types of protected pages that you might have, user-specific and non-user-specific. If a protected page is user-specific, then it's useless without the user's personal data. For example, a list of bank statements is completely worthless to an attacker without the user's bank statements populating it, rather than a loading skeleton. For these kinds of pages, we can render a skeleton on the server that's then populated with the user's information once the page is loaded in the browser. This means we don't have to go to any extra lengths to prevent access to the skeleton, since we'll assume that the user's data can only be accessed over an APi that needs some unique token that can only be generated with the user's password, or something similar.</p>\\n<p>If a protected page is non-user-specific, that means it contains content that's the same for all users, but that should only be accessible to users who have logged in. These are more complex because protecting them requires that you don't prerender them on the server at all, and that the code for the protected content not be in your codebase. That may seem weird -- how can you render it at all if it's not in your codebase? Well, you'd have to check if the user is authenticated, and then use some token to fetch the protected content from a server and then display that. If you were to have the protected content anywhere in your code, then it would be accessible to any user willing to reverse-engineer the generated WebAssembly (which isn't too tricky), and hence not really protected at all.</p>\\n<h2>Secure Authentication</h2>\\n<p>TODO</p>\\n<h2>Building the App</h2>\\n<h3>Setup</h3>\\n<p>To start with, we'll set up a fairly typical Perseus app by initializing a new Rust project with <code>cargo new --lib</code>. Then, put the following in <code>Cargo.toml</code> (changing the package name as you want):</p>\\n<pre><code class=\\"language-toml\\">[package]\\nname = &quot;perseus-example-auth&quot;\\nversion = &quot;0.3.5&quot;\\nedition = &quot;2018&quot;\\n\\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\\n\\n[dependencies]\\n# We can't use hydration here yet (it doesn't handle the rapid page changes from unauthenticated to authenticated well)\\nperseus = { path = &quot;../../../packages/perseus&quot;, features = [] }\\nsycamore = &quot;0.7&quot;\\nserde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }\\nserde_json = &quot;1&quot;\\n# We need the \`HtmlDocument\` feature to be able to use cookies (which this example does)\\nweb-sys = { version = &quot;0.3&quot;, features = [ &quot;Storage&quot; ] }\\n\\n</code></pre>\\n<p>The only things of particular note here are the dependency on <code>web-sys</code>, from which we use the <code>Storage</code> feature (important later), as well as not using Sycamore's <a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/hydration\\">hydration</a> system, as it doesn't handle the kinds of page changes from unauthenticated to authenticated that we'll need in this app. Note that hydration will likely work fine with this in future version of Sycamore (it's currently experimental though).</p>\\n<p>Now add the following to <code>src/lib.rs</code>:</p>\\n<pre><code class=\\"language-rust\\">mod error_pages;\\nmod global_state;\\nmod templates;\\n\\nuse perseus::{Html, PerseusApp};\\n\\n#[perseus::main]\\npub fn main&lt;G: Html&gt;() -&gt; PerseusApp&lt;G&gt; {\\n    PerseusApp::new()\\n        .template(crate::templates::index::get_template)\\n        .template(crate::templates::about::get_template)\\n        .error_pages(crate::error_pages::get_error_pages)\\n        .global_state_creator(crate::global_state::get_global_state_creator())\\n}\\n\\n</code></pre>\\n<p>This is a very typical scaffold, but the use of the global state creator is important, and that's what we'll look at next. You can put whatever you want into <code>src/error_pages.rs</code> to serve as your app's error pages, but that isn't the subject of this tutorial. You can read more about error pages <a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/error-pages\\">here</a> though.</p>\\n<p>In <code>src/global_state.rs</code>, put the following code:</p>\\n<pre><code class=\\"language-rust\\">use perseus::{state::GlobalStateCreator, RenderFnResult};\\nuse serde::{Deserialize, Serialize};\\n\\npub fn get_global_state_creator() -&gt; GlobalStateCreator {\\n    GlobalStateCreator::new().build_state_fn(get_build_state)\\n}\\n\\n#[perseus::autoserde(global_build_state)]\\npub async fn get_build_state() -&gt; RenderFnResult&lt;AppState&gt; {\\n    Ok(AppState {\\n        // We explicitly tell the first page that no login state has been checked yet\\n        auth: AuthData {\\n            state: LoginState::Server,\\n            username: String::new(),\\n        },\\n    })\\n}\\n\\n#[perseus::make_rx(AppStateRx)]\\n#[rx::nested(&quot;auth&quot;, AuthDataRx)]\\npub struct AppState {\\n    /// Authentication data accessible to all pages.\\n    pub auth: AuthData,\\n}\\n\\n/// The possible login states, including one for the server.\\n// A better structure might have \`Yes\` have an attached \`AuthData\` and use this as the top-level element, but then we'd have to implement \`MakeRx\`/\`MakeUnrx\` manually on this (\`make_rx\`\\n// can't handle \`enum\`s)\\n#[derive(Clone, Serialize, Deserialize)]\\npub enum LoginState {\\n    Yes,\\n    No,\\n    Server,\\n}\\n\\n/// Authentication data for the app.\\n// In a real app, you might store privileges here, or user preferences, etc. (all the things you'd need to have available constantly and everwhere)\\n#[perseus::make_rx(AuthDataRx)]\\npub struct AuthData {\\n    /// The actual login status.\\n    pub state: LoginState,\\n    /// The user's username.\\n    pub username: String,\\n}\\n// We implement a custom function on the reactive version of the global state here (hence the \`.get()\`s and \`.set()\`s, all the fields become \`Signal\`s)\\n// There's no point in implementing it on the unreactive version, since this will only be called from within the browser, in which we have a reactive version\\nimpl AuthDataRx {\\n    /// Checks whether or not the user is logged in and modifies the internal state accordingly. If this has already been run, it won't do anything (aka. it will only run if it's \`Server\`)\\n    #[cfg(target_arch = &quot;wasm32&quot;)] // This just avoids an unused function warning (since we have to gate the \`.update()\` call)\\n    pub fn detect_state(&amp;self) {\\n        // If we've checked the login status before, then we should assume the status hasn't changed (we'd change this in a login/logout page)\\n        if let LoginState::Yes | LoginState::No = *self.state.get() {\\n            return;\\n        }\\n\\n        // See the docs page on authentication to learn how to put something *secure* here\\n        // This example is NOT production-safe, and would result in absolutely terrible security!!!\\n\\n        // All we're doing in here is checking for the existence of a storage entry that contains a username (any attacker could trivially fake this)\\n        // Note that this storage API may be inaccessible, which we completely ignore here for simplicity\\n        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();\\n        let auth_token = storage.get(&quot;username&quot;).unwrap(); // This is a \`Result&lt;Option&lt;T&gt;, E&gt;\`\\n\\n        if let Some(username) = auth_token {\\n            self.username.set(username.to_string());\\n            self.state.set(LoginState::Yes);\\n        } else {\\n            self.username.set(String::new());\\n            self.state.set(LoginState::No)\\n        }\\n    }\\n\\n    /// Logs the user in with the given username.\\n    pub fn login(&amp;self, username: &amp;str) {\\n        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();\\n        storage.set(&quot;username&quot;, username).unwrap();\\n        self.state.set(LoginState::Yes);\\n        self.username.set(username.to_string());\\n    }\\n    /// Logs the user out.\\n    pub fn logout(&amp;self) {\\n        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();\\n        storage.delete(&quot;username&quot;).unwrap();\\n        self.state.set(LoginState::No);\\n        self.username.set(String::new());\\n    }\\n}\\n\\n</code></pre>\\n<p>This is fairly intense, so let's break it down.</p>\\n<p>The first thing we do is create the function we call from <code>src/lib.rs</code>, <code>get_global_state_creator</code>, which initializes a <code>GlobalStateCreator</code> with the <code>get_build_state</code> function to create the initial global state (generated on the server and passed to the client). What that function does is generates an instance of <code>AppState</code>, a <code>struct</code> that will store our app's global state (which can include anything you want), which crucially has the <code>auth</code> field, an instance of <code>AuthData</code>, which will store the data for user authentication. Notably, all these <code>struct</code>s are annotated with <code>.make_rx()</code> to make them work with Perseus' state platform (note that <code>AppState</code> declares nested reactivity for the <code>auth</code> field, which you can read more about <a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global\\">here</a>).</p>\\n<p><code>AuthData</code> has two fields: <code>state</code> and <code>username</code>. The first is a <code>LoginState</code>, which can be <code>Yes</code> (the user is logged in), <code>No</code> (the user is not logged in), or <code>Server</code> (the page has been rendered on the server and we don't have any information about the user's login status yet). The reason for these three possibilities is so we don't assume the user to be logged out before we've even gotten to their browser, as that might result in an ugly flash between pages, or worse an inappropriate redirection to a login page. By forcing ourselves to handle the <code>Server</code> case, we make our code more robust and clearer.</p>\\n<p>You might be wondering why we don't store <code>username</code>, which is just a <code>String</code>, as a property of <code>LoginState::Yes</code>, which would seem to be a much smarter data structure. This is absolutely true, but the problem is that the <code>make_rx</code> macro isn't smart enough to handle <code>enum</code>s, so we'd have to implement the <code>MakeRx</code> trait manually, which is a little tedious. To keep things simple, we'll go with storing <code>username</code> separately, but if you have multiple fields of information only relevant to authenticated users, you may want to take the more complex approach for cleanliness.</p>\\n<p>Next, we implement some functions on <code>AuthDataRx</code>, the reactive version of <code>AuthData</code>, not bothering to do so on the original because we'll only use these functions in templates, in which we have the reactive version. The first method is <code>.detect_state()</code>, which will, if the state is <code>LoginState::Server</code>, check if the user is logged in by checking the <code>username</code> key in the browser's storage (not IndexedDB, local storage instead, which is more appropriate for this sort of thing). Note that this kind of 'token' management is absolutely atrocious and completely insecure, and serves only as an example of how you might start with authentication. Do NOT use this in a production app!</p>\\n<p>The only other two functions are very simple, just <code>.login()</code> and <code>.logout()</code>, which alter the storage key and the global state to register a new login state.</p>\\n<h2>Templates</h2>\\n<p>Okay, let's get into writing some views based on all this! We'll create an index page and an about page for demonstration, so set up a <code>src/templates/</code> directory with a <code>mod.rs</code> that declares both files. Then put the following in <code>src/templates/index.rs</code>:</p>\\n<pre><code class=\\"language-rust\\">use crate::global_state::{AppStateRx, LoginState};\\nuse perseus::{Html, Template};\\nuse sycamore::prelude::*;\\n\\n#[perseus::template_rx]\\nfn index_view(_: (), AppStateRx { auth }: AppStateRx) -&gt; View&lt;G&gt; {\\n    // This isn't part of our data model because it's only used here to pass to the login function\\n    let entered_username = Signal::new(String::new());\\n    let eu_2 = entered_username.clone();\\n\\n    // We have to trigger this from outside the \`create_memo\`, and we should only be interacting with storage APIs in the browser (otherwise this would be called on the server too)\\n    // This will only cause a block on the first load, because this function just returns straight away if the state is already known\\n    #[cfg(target_arch = &quot;wasm32&quot;)]\\n    auth.detect_state();\\n\\n    // We make the view as a memo outside the root \`view!\` for better editor support (some editors don't like highlighting code in macros)\\n    // We need to clone \`global_state\` because otherwise the \`Signal\` updates won't be registered\\n    let view = create_memo(cloned!(auth =&gt; move || {\\n        match *auth.state.get() {\\n            LoginState::Yes =&gt; {\\n                let username = auth.username.get();\\n                view! {\\n                    h1 { (format!(&quot;Welcome back, {}!&quot;, &amp;username)) }\\n                    button(on:click = cloned!(auth =&gt; move |_| {\\n                        auth.logout();\\n                    })) { &quot;Logout&quot; }\\n                }\\n            }\\n            // You could also redirect the user to a dedicated login page\\n            LoginState::No =&gt; view! {\\n                h1 { &quot;Welcome, stranger!&quot; }\\n                input(bind:value = entered_username.clone(), placeholder = &quot;Username&quot;)\\n                    button(on:click = cloned!(eu_2, auth =&gt; move |_| {\\n                        auth.login(&amp;eu_2.get())\\n                    })) { &quot;Login&quot; }\\n            },\\n            // This will appear for a few moments while we figure out if the user is logged in or not\\n            LoginState::Server =&gt; View::empty(),\\n        }\\n    }));\\n    view! {\\n        (*view.get())\\n        br()\\n        a(href = &quot;about&quot;) { &quot;About&quot; }\\n    }\\n}\\n\\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\\n    Template::new(&quot;index&quot;).template(index_view)\\n}\\n\\n</code></pre>\\n<p>The only strange stuff in here is in <code>index_view()</code>, the rest is pretty much bog-standard Perseus template code. In <code>index_view()</code>, we don't take any template sttate, for demonstration purposes (you easily could), but we do take in the global state, which you'll remember contains all the authentication properties. Then we set up some <code>Signal</code>s outside the data model for handling a very simple login input (again, demonstrations). The important thing is the call to <code>auth.detect_state()</code>, which will refresh the authentication status by checking the user's browser for the login 'token' being stored. Note that, because we coded this to return straight away if we already know the login state, it's perfectly safe to put this at the start of every template you want to be authentication-protected. We also gate this with <code>#[cfg(target_arch = &quot;wasm32&quot;)]</code> to make sure it only runs on the browser (because we can't check for storage tokens in the server build process, that will throw plenty of errors!).</p>\\n<p>Skipping past the scary <code>let view = ...</code> block for a moment, the end of this function is dead simple: we just display a Sycamore <code>View&lt;G&gt;</code> stored in a <code>Signal</code> (that's in the <code>view</code> variable), and then a link to the about page. Anything other than that <code>(*view.get())</code> call will be displayed <em>whether the user is authenticated or not</em>.</p>\\n<p>Now for the fun part. To give us maximum editor support and cleanliness, we define the bulk of the view code outside the <code>view!</code> macro and in a variable called <code>view</code> instead, a derived <code>Signal</code> built with <code>create_memo</code> running on <code>auth.state</code>. So, if <code>auth.state</code> changes, this will also update immediately and automatically! All we do here is handle each of the three possible authentication states with a <code>match</code> statement: if we're on the server, we'll display nothing at all; if the user isn't logged in, a login page; and if they are, a welcome message and a logout button. In a real-world app, you'd probably have some code that redirects the user to a login page in the <code>LoginState::No</code> case.</p>\\n<p>You might be wondering why we display nothing before the login state is known, because this would seem to undercut the purpose of preloading the page at all. The answer to this question is that it does, and in an ideal world you'd process the user's login data on the server-side before serving them the appropriate prerendered page, which you <em>could</em> do, but that would be unnecessarily complex. Instead, we can display a blank page for a moment before redirecting or loading the appropriate skeleton.</p>\\n<p>In theory though, on some odler mobile devices, this blank screen might be visible for more than a moment (on 3G networks, it could be 2 seconds or more), which is not good at all. To remedy this, you could make <code>LoginState::Server</code> and <code>LoginState::Yes</code> render the same skeleton (with some blanks for unfetched user information), so you're essentially assuming the user to be logged in. That means only anonymous users get a flash, from the skeleton to a login page. If your login page is at a central route (e.g. <code>/login</code>), you could inject some JavaScript code to run before any of your page is rendered that would check if the user is logged in, and then redirect them to the login page before any of the page loaded if not. This is the best solution, which involves no flashing whatsoever, and the display time of your app is optimized for all users, without needing any server-side code!</p>\\n<p><em>Note: in future, there will likely be a plugin to perform this optimization automatically. If someone wants to create this now, please open a PR!</em></p>\\n<p>Finally, add the following into the about page (just a very basic unprotected page for comparison):</p>\\n<pre><code class=\\"language-rust\\">use perseus::Template;\\nuse sycamore::prelude::{view, Html, View};\\n\\n#[perseus::template_rx]\\npub fn about_page() -&gt; View&lt;G&gt; {\\n    view! {\\n        p { &quot;About.&quot; }\\n        a(href = &quot;&quot;) { &quot;Index&quot; }\\n    }\\n}\\n\\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\\n    Template::new(&quot;about&quot;).template(about_page)\\n}\\n\\n</code></pre>\\n<h2>Conclusion</h2>\\n<p>Authentication in Perseus is fairly easy to implement, easier than in many other frameworks, though there are a few hurdles to get over and patterns to understand that will make your code more idiomatic. In future, nearly all this will likely be handled automatically by a plugin or library, which would enable more rapid and efficient development of complex apps. For now though, authentication must be built manually into Perseus apps.</p>\\n","sidebar_content":"<h1>Introduction</h1>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/intro\\">Introduction</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/what-is-perseus\\">What is Perseus?</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/core-principles\\">Core Principles</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/hello-world\\">Hello World!</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/second-app\\">Your Second App</a></li>\\n</ul>\\n<hr />\\n<h1>Reference</h1>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/perseus-app\\"><code>PerseusApp</code></a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/define-app\\"><code>define_app!</code></a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/views\\">Writing Views</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/index-view\\">The Index View</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/debugging\\">Debugging</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/live-reloading\\">Live Reloading</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/intro\\">Templates and Routing</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/metadata-modification\\">Modifying the <code>&lt;head&gt;</code></a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/setting-headers\\">Modifying HTTP Headers</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/router-state\\">Listening to the Router</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/error-pages\\">Error Pages</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/static-content\\">Static Content</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/intro\\">Internationalization</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/defining\\">Defining Translations</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/using\\">Using Translations</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/translations-managers\\">Translations Managers</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/other-engines\\">Other Translation Engines</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/intro\\">Rendering Strategies</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-state\\">Build State</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-paths\\">Build Paths</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/request-state\\">Request State</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/revalidation\\">Revalidation</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/incremental\\">Incremental Generation</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/amalgamation\\">State Amalgamation</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/hydration\\">Hydration</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/rx\\">Reactive State</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global\\">Global State</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/freezing\\">State Freezing</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/idb-freezing\\">Freezing to IndexedDB</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/hsr\\">Hot State Reloading (HSR)</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/cli\\">CLI</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/ejecting\\">Ejecting</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/snooping\\">Snooping</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/intro\\">Testing</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/checkpoints\\">Checkpoints</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/fantoccini-basics\\">Fantoccini Basics</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/manual\\">Manual Testing</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/styling\\">Styling</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/server-communication\\">Communicating with a Server</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/stores\\">Stores</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/exporting\\">Static Exporting</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/intro\\">Plugins</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/functional\\">Functional Actions</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/control\\">Control Actions</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/using\\">Using Plugins</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/tinker\\">The <code>tinker</code> Action</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/writing\\">Writing Plugins</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/security\\">Security Considerations</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/publishing\\">Publishing Plugins</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/engines\\">Engines</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/intro\\">Deploying</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverful\\">Server Deployment</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverless\\">Serverless Deployment</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/size\\">Optimizing Code Size</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/relative-paths\\">Relative Paths</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/docker\\">Docker Deployment</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/updating\\">Migrating from v0.3.3</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/pitfalls-and-bugs\\">Common Pitfalls and Known Bugs</a></li>\\n</ul>\\n<hr />\\n<h1>Advanced</h1>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/intro\\">Under the Hood</a>\\n<ul>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/arch\\">Architecture</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/initial-loads\\">Initial Loads</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/subsequent-loads\\">Subsequent Loads</a></li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/routing\\">Routing</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/route-announcer\\">Route Announcer</a></li>\\n</ul>\\n<hr />\\n<h1>Further Tutorials</h1>\\n<ul>\\n<li><a href=\\"docs/tutorials/auth\\">Authentication</a></li>\\n</ul>\\n","status":"Stable","manifest":{"0.2.x":{"state":"outdated","git":"v0.2.3","docs_rs":"0.2"},"0.1.x":{"state":"outdated","git":"v0.1.4","docs_rs":"0.1"},"0.3.0-0.3.3":{"state":"outdated","git":"v0.3.3","docs_rs":"0.3.3"},"0.3.4":{"state":"stable","git":"eccf137032fbe8e6507be9e9317edc16e7576a4f","docs_rs":"0.3"},"0.4.x":{"state":"beta","git":"HEAD","docs_rs":"0.4.0-beta"}},"current_version":"0.3.4"}`;</script>
            </head><body  class="bg-white dark:bg-navy"><div><div id="root"><div id="__perseus_content_initial" class="__perseus_content"><header data-hk="1.1" class="shadow-md sm:p-2 w-full bg-white dark:text-white dark:bg-navy mb-20"><div data-hk="1.2" class="flex justify-between"><a data-hk="1.3" class="justify-self-start self-center m-3 ml-5 text-md sm:text-2xl" href="en-US/">Perseus</a><div data-hk="1.4" class="md:hidden m-3 mr-5 tham tham-e-spin tham-w-6 "><div data-hk="1.5" class="tham-box"><div data-hk="1.6" class="dark:bg-white tham-inner"></div></div></div><nav data-hk="1.7" class="hidden md:flex"><ul data-hk="1.8" class="mr-5 flex"><li data-hk="2.0" class="m-3 p-1"><a data-hk="2.1" href="en-US/docs" class="px-2">Docs</a></li><li data-hk="2.2" class="m-3 p-1"><a data-hk="2.3" href="en-US/comparisons" class="px-2">Comparisons</a></li><li data-hk="2.4" class="m-3 p-1"><a data-hk="2.5" href="en-US/plugins" class="px-2">Plugins</a></li></ul></nav></div><nav data-hk="1.9" id="mobile_nav_menu" class="md:hidden w-full text-center justify-center overflow-y-scroll hidden"><div data-hk="1.10" class="mr-5 overflow-y-scroll" style="max-height: 500px"><ul data-hk="1.11"><li data-hk="3.0" class="m-3 p-1"><a data-hk="3.1" href="en-US/docs" class="px-2">Docs</a></li><li data-hk="3.2" class="m-3 p-1"><a data-hk="3.3" href="en-US/comparisons" class="px-2">Comparisons</a></li><li data-hk="3.4" class="m-3 p-1"><a data-hk="3.5" href="en-US/plugins" class="px-2">Plugins</a></li></ul><hr data-hk="1.12"/><div data-hk="1.13" class="text-left p-3"><!--#--><!----><select data-hk="4.4" class="p-2 rounded-md text-white bg-indigo-500"><option data-hk="4.5" value="next">Next (unreleased)</option><option data-hk="4.0" value="0.4.x">v⁨0.4.x⁩ (beta)</option><option data-hk="4.6" value="0.3.4" selected="">v⁨0.3.4⁩ (stable)</option><option data-hk="4.1" value="0.3.0-0.3.3">v⁨0.3.0-0.3.3⁩ (outdated)</option><option data-hk="4.2" value="0.2.x">v⁨0.2.x⁩ (outdated)</option><option data-hk="4.3" value="0.1.x">v⁨0.1.x⁩ (outdated)</option></select><!--/--><div data-hk="1.14" class="docs-links-markdown"><h1>Introduction</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/intro">Introduction</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/what-is-perseus">What is Perseus?</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/core-principles">Core Principles</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/hello-world">Hello World!</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/second-app">Your Second App</a></li>
</ul>
<hr />
<h1>Reference</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/perseus-app"><code>PerseusApp</code></a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/define-app"><code>define_app!</code></a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/views">Writing Views</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/index-view">The Index View</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/debugging">Debugging</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/live-reloading">Live Reloading</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/intro">Templates and Routing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/metadata-modification">Modifying the <code>&lt;head&gt;</code></a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/setting-headers">Modifying HTTP Headers</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/router-state">Listening to the Router</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/error-pages">Error Pages</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/static-content">Static Content</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/intro">Internationalization</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/defining">Defining Translations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/using">Using Translations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/translations-managers">Translations Managers</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/other-engines">Other Translation Engines</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/intro">Rendering Strategies</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-state">Build State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-paths">Build Paths</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/request-state">Request State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/revalidation">Revalidation</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/incremental">Incremental Generation</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/amalgamation">State Amalgamation</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/hydration">Hydration</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/rx">Reactive State</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global">Global State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/freezing">State Freezing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/idb-freezing">Freezing to IndexedDB</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/hsr">Hot State Reloading (HSR)</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/cli">CLI</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/ejecting">Ejecting</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/snooping">Snooping</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/intro">Testing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/checkpoints">Checkpoints</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/fantoccini-basics">Fantoccini Basics</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/manual">Manual Testing</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/styling">Styling</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/server-communication">Communicating with a Server</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/stores">Stores</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/exporting">Static Exporting</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/intro">Plugins</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/functional">Functional Actions</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/control">Control Actions</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/using">Using Plugins</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/tinker">The <code>tinker</code> Action</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/writing">Writing Plugins</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/security">Security Considerations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/publishing">Publishing Plugins</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/engines">Engines</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/intro">Deploying</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverful">Server Deployment</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverless">Serverless Deployment</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/size">Optimizing Code Size</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/relative-paths">Relative Paths</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/docker">Docker Deployment</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/updating">Migrating from v0.3.3</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/pitfalls-and-bugs">Common Pitfalls and Known Bugs</a></li>
</ul>
<hr />
<h1>Advanced</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/intro">Under the Hood</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/arch">Architecture</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/initial-loads">Initial Loads</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/subsequent-loads">Subsequent Loads</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/routing">Routing</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/route-announcer">Route Announcer</a></li>
</ul>
<hr />
<h1>Further Tutorials</h1>
<ul>
<li><a href="docs/tutorials/auth">Authentication</a></li>
</ul>
</div></div></div></nav></header><div data-hk="1.15" class="mt-14 xs:mt-16 sm:mt-20 lg:mt-25 overflow-y-auto flex"><div data-hk="1.16" class="flex w-full"><div data-hk="1.17" class="h-full hidden md:block max-w-xs w-full border-r"><div data-hk="1.18" class="mr-5"><div data-hk="1.19" class="text-left text-black dark:text-white p-3"><aside data-hk="1.20"><!--#--><!----><select data-hk="5.4" class="p-2 rounded-md text-white bg-indigo-500"><option data-hk="5.5" value="next">Next (unreleased)</option><option data-hk="5.0" value="0.4.x">v⁨0.4.x⁩ (beta)</option><option data-hk="5.6" value="0.3.4" selected="">v⁨0.3.4⁩ (stable)</option><option data-hk="5.1" value="0.3.0-0.3.3">v⁨0.3.0-0.3.3⁩ (outdated)</option><option data-hk="5.2" value="0.2.x">v⁨0.2.x⁩ (outdated)</option><option data-hk="5.3" value="0.1.x">v⁨0.1.x⁩ (outdated)</option></select><!--/--><div data-hk="1.21" class="docs-links-markdown"><h1>Introduction</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/intro">Introduction</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/what-is-perseus">What is Perseus?</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/core-principles">Core Principles</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/hello-world">Hello World!</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/tutorials/second-app">Your Second App</a></li>
</ul>
<hr />
<h1>Reference</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/perseus-app"><code>PerseusApp</code></a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/define-app"><code>define_app!</code></a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/views">Writing Views</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/index-view">The Index View</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/debugging">Debugging</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/live-reloading">Live Reloading</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/intro">Templates and Routing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/metadata-modification">Modifying the <code>&lt;head&gt;</code></a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/setting-headers">Modifying HTTP Headers</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/templates/router-state">Listening to the Router</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/error-pages">Error Pages</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/static-content">Static Content</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/intro">Internationalization</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/defining">Defining Translations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/using">Using Translations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/translations-managers">Translations Managers</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/i18n/other-engines">Other Translation Engines</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/intro">Rendering Strategies</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-state">Build State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/build-paths">Build Paths</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/request-state">Request State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/revalidation">Revalidation</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/incremental">Incremental Generation</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/strategies/amalgamation">State Amalgamation</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/hydration">Hydration</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/rx">Reactive State</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global">Global State</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/freezing">State Freezing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/idb-freezing">Freezing to IndexedDB</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/hsr">Hot State Reloading (HSR)</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/cli">CLI</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/ejecting">Ejecting</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/snooping">Snooping</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/intro">Testing</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/checkpoints">Checkpoints</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/fantoccini-basics">Fantoccini Basics</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/testing/manual">Manual Testing</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/styling">Styling</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/server-communication">Communicating with a Server</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/stores">Stores</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/exporting">Static Exporting</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/intro">Plugins</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/functional">Functional Actions</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/control">Control Actions</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/using">Using Plugins</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/tinker">The <code>tinker</code> Action</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/writing">Writing Plugins</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/security">Security Considerations</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/plugins/publishing">Publishing Plugins</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/engines">Engines</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/intro">Deploying</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverful">Server Deployment</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/serverless">Serverless Deployment</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/size">Optimizing Code Size</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/relative-paths">Relative Paths</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/deploying/docker">Docker Deployment</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/updating">Migrating from v0.3.3</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/pitfalls-and-bugs">Common Pitfalls and Known Bugs</a></li>
</ul>
<hr />
<h1>Advanced</h1>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/intro">Under the Hood</a>
<ul>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/arch">Architecture</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/initial-loads">Initial Loads</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/subsequent-loads">Subsequent Loads</a></li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/routing">Routing</a></li>
</ul>
</li>
<li><a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/advanced/route-announcer">Route Announcer</a></li>
</ul>
<hr />
<h1>Further Tutorials</h1>
<ul>
<li><a href="docs/tutorials/auth">Authentication</a></li>
</ul>
</div></aside></div></div></div><div data-hk="1.22" class="h-full flex w-full"><div data-hk="1.23" class="px-3 w-full sm:mr-auto sm:ml-auto sm:max-w-prose lg:max-w-3xl xl:max-w-4xl 2xl:max-w-5xl"><!--#--><!----><!--/--><main data-hk="1.24" class="text-black dark:text-white"><div data-hk="1.0" class="markdown"><h1>Authentication</h1>
<p>If you're building an app with multiple users that might have different preferences or the like, chances are you'll need some way for those users to log in, you'll need an authentication system. This is fairly easy to achieve in Perseus with the <a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global">global state</a> system, though there are a few gotchas -- hence this tutorial!</p>
<h2>Concepts</h2>
<p>Authentication as a process involves the user wanting to go to some page that they need to be logged in to access (e.g. a dashboard of bank statements), logging in, accessing that page, and then maybe logging back out a little later. All that really boils down to in terms of code is a system to manage whether or not the user is logged in, a system of authenticating the user's password (or however else they're logging in), and a system of providing access on certain pages only to authenticated users.</p>
<p>The first part can be achieved through an entry in an app's global state that describes whether or not the user is logged in, what their username is, etc. Notably, this could be saved through <a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/freezing">state freezing</a> to IndexedDB (which would preserve all the properties of the user's login) (not covered in this tutorial), though we still need a way of securely confirming that the user is who they say they are. For that, we would need to store a token, often done in the browser's <a href="TODO">local storage</a> API, which we'll use in this example. As for how this token works, that requires a good deal of thought to security and how your app will work, and so is elided here (we'll just use a very insecure 'token' that tells us what the user's username is).</p>
<p>The final part of this is controlling access to protected pages, which is the part where Perseus becomes more relevant as a framework. There are two types of protected pages that you might have, user-specific and non-user-specific. If a protected page is user-specific, then it's useless without the user's personal data. For example, a list of bank statements is completely worthless to an attacker without the user's bank statements populating it, rather than a loading skeleton. For these kinds of pages, we can render a skeleton on the server that's then populated with the user's information once the page is loaded in the browser. This means we don't have to go to any extra lengths to prevent access to the skeleton, since we'll assume that the user's data can only be accessed over an APi that needs some unique token that can only be generated with the user's password, or something similar.</p>
<p>If a protected page is non-user-specific, that means it contains content that's the same for all users, but that should only be accessible to users who have logged in. These are more complex because protecting them requires that you don't prerender them on the server at all, and that the code for the protected content not be in your codebase. That may seem weird -- how can you render it at all if it's not in your codebase? Well, you'd have to check if the user is authenticated, and then use some token to fetch the protected content from a server and then display that. If you were to have the protected content anywhere in your code, then it would be accessible to any user willing to reverse-engineer the generated WebAssembly (which isn't too tricky), and hence not really protected at all.</p>
<h2>Secure Authentication</h2>
<p>TODO</p>
<h2>Building the App</h2>
<h3>Setup</h3>
<p>To start with, we'll set up a fairly typical Perseus app by initializing a new Rust project with <code>cargo new --lib</code>. Then, put the following in <code>Cargo.toml</code> (changing the package name as you want):</p>
<pre><code class="language-toml">[package]
name = &quot;perseus-example-auth&quot;
version = &quot;0.3.5&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# We can't use hydration here yet (it doesn't handle the rapid page changes from unauthenticated to authenticated well)
perseus = { path = &quot;../../../packages/perseus&quot;, features = [] }
sycamore = &quot;0.7&quot;
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1&quot;
# We need the `HtmlDocument` feature to be able to use cookies (which this example does)
web-sys = { version = &quot;0.3&quot;, features = [ &quot;Storage&quot; ] }

</code></pre>
<p>The only things of particular note here are the dependency on <code>web-sys</code>, from which we use the <code>Storage</code> feature (important later), as well as not using Sycamore's <a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/hydration">hydration</a> system, as it doesn't handle the kinds of page changes from unauthenticated to authenticated that we'll need in this app. Note that hydration will likely work fine with this in future version of Sycamore (it's currently experimental though).</p>
<p>Now add the following to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust">mod error_pages;
mod global_state;
mod templates;

use perseus::{Html, PerseusApp};

#[perseus::main]
pub fn main&lt;G: Html&gt;() -&gt; PerseusApp&lt;G&gt; {
    PerseusApp::new()
        .template(crate::templates::index::get_template)
        .template(crate::templates::about::get_template)
        .error_pages(crate::error_pages::get_error_pages)
        .global_state_creator(crate::global_state::get_global_state_creator())
}

</code></pre>
<p>This is a very typical scaffold, but the use of the global state creator is important, and that's what we'll look at next. You can put whatever you want into <code>src/error_pages.rs</code> to serve as your app's error pages, but that isn't the subject of this tutorial. You can read more about error pages <a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/error-pages">here</a> though.</p>
<p>In <code>src/global_state.rs</code>, put the following code:</p>
<pre><code class="language-rust">use perseus::{state::GlobalStateCreator, RenderFnResult};
use serde::{Deserialize, Serialize};

pub fn get_global_state_creator() -&gt; GlobalStateCreator {
    GlobalStateCreator::new().build_state_fn(get_build_state)
}

#[perseus::autoserde(global_build_state)]
pub async fn get_build_state() -&gt; RenderFnResult&lt;AppState&gt; {
    Ok(AppState {
        // We explicitly tell the first page that no login state has been checked yet
        auth: AuthData {
            state: LoginState::Server,
            username: String::new(),
        },
    })
}

#[perseus::make_rx(AppStateRx)]
#[rx::nested(&quot;auth&quot;, AuthDataRx)]
pub struct AppState {
    /// Authentication data accessible to all pages.
    pub auth: AuthData,
}

/// The possible login states, including one for the server.
// A better structure might have `Yes` have an attached `AuthData` and use this as the top-level element, but then we'd have to implement `MakeRx`/`MakeUnrx` manually on this (`make_rx`
// can't handle `enum`s)
#[derive(Clone, Serialize, Deserialize)]
pub enum LoginState {
    Yes,
    No,
    Server,
}

/// Authentication data for the app.
// In a real app, you might store privileges here, or user preferences, etc. (all the things you'd need to have available constantly and everwhere)
#[perseus::make_rx(AuthDataRx)]
pub struct AuthData {
    /// The actual login status.
    pub state: LoginState,
    /// The user's username.
    pub username: String,
}
// We implement a custom function on the reactive version of the global state here (hence the `.get()`s and `.set()`s, all the fields become `Signal`s)
// There's no point in implementing it on the unreactive version, since this will only be called from within the browser, in which we have a reactive version
impl AuthDataRx {
    /// Checks whether or not the user is logged in and modifies the internal state accordingly. If this has already been run, it won't do anything (aka. it will only run if it's `Server`)
    #[cfg(target_arch = &quot;wasm32&quot;)] // This just avoids an unused function warning (since we have to gate the `.update()` call)
    pub fn detect_state(&amp;self) {
        // If we've checked the login status before, then we should assume the status hasn't changed (we'd change this in a login/logout page)
        if let LoginState::Yes | LoginState::No = *self.state.get() {
            return;
        }

        // See the docs page on authentication to learn how to put something *secure* here
        // This example is NOT production-safe, and would result in absolutely terrible security!!!

        // All we're doing in here is checking for the existence of a storage entry that contains a username (any attacker could trivially fake this)
        // Note that this storage API may be inaccessible, which we completely ignore here for simplicity
        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();
        let auth_token = storage.get(&quot;username&quot;).unwrap(); // This is a `Result&lt;Option&lt;T&gt;, E&gt;`

        if let Some(username) = auth_token {
            self.username.set(username.to_string());
            self.state.set(LoginState::Yes);
        } else {
            self.username.set(String::new());
            self.state.set(LoginState::No)
        }
    }

    /// Logs the user in with the given username.
    pub fn login(&amp;self, username: &amp;str) {
        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();
        storage.set(&quot;username&quot;, username).unwrap();
        self.state.set(LoginState::Yes);
        self.username.set(username.to_string());
    }
    /// Logs the user out.
    pub fn logout(&amp;self) {
        let storage = web_sys::window().unwrap().local_storage().unwrap().unwrap();
        storage.delete(&quot;username&quot;).unwrap();
        self.state.set(LoginState::No);
        self.username.set(String::new());
    }
}

</code></pre>
<p>This is fairly intense, so let's break it down.</p>
<p>The first thing we do is create the function we call from <code>src/lib.rs</code>, <code>get_global_state_creator</code>, which initializes a <code>GlobalStateCreator</code> with the <code>get_build_state</code> function to create the initial global state (generated on the server and passed to the client). What that function does is generates an instance of <code>AppState</code>, a <code>struct</code> that will store our app's global state (which can include anything you want), which crucially has the <code>auth</code> field, an instance of <code>AuthData</code>, which will store the data for user authentication. Notably, all these <code>struct</code>s are annotated with <code>.make_rx()</code> to make them work with Perseus' state platform (note that <code>AppState</code> declares nested reactivity for the <code>auth</code> field, which you can read more about <a href="https://arctic-hen7.github.io/perseus/en-US/docs/0.3.4/reference/state/global">here</a>).</p>
<p><code>AuthData</code> has two fields: <code>state</code> and <code>username</code>. The first is a <code>LoginState</code>, which can be <code>Yes</code> (the user is logged in), <code>No</code> (the user is not logged in), or <code>Server</code> (the page has been rendered on the server and we don't have any information about the user's login status yet). The reason for these three possibilities is so we don't assume the user to be logged out before we've even gotten to their browser, as that might result in an ugly flash between pages, or worse an inappropriate redirection to a login page. By forcing ourselves to handle the <code>Server</code> case, we make our code more robust and clearer.</p>
<p>You might be wondering why we don't store <code>username</code>, which is just a <code>String</code>, as a property of <code>LoginState::Yes</code>, which would seem to be a much smarter data structure. This is absolutely true, but the problem is that the <code>make_rx</code> macro isn't smart enough to handle <code>enum</code>s, so we'd have to implement the <code>MakeRx</code> trait manually, which is a little tedious. To keep things simple, we'll go with storing <code>username</code> separately, but if you have multiple fields of information only relevant to authenticated users, you may want to take the more complex approach for cleanliness.</p>
<p>Next, we implement some functions on <code>AuthDataRx</code>, the reactive version of <code>AuthData</code>, not bothering to do so on the original because we'll only use these functions in templates, in which we have the reactive version. The first method is <code>.detect_state()</code>, which will, if the state is <code>LoginState::Server</code>, check if the user is logged in by checking the <code>username</code> key in the browser's storage (not IndexedDB, local storage instead, which is more appropriate for this sort of thing). Note that this kind of 'token' management is absolutely atrocious and completely insecure, and serves only as an example of how you might start with authentication. Do NOT use this in a production app!</p>
<p>The only other two functions are very simple, just <code>.login()</code> and <code>.logout()</code>, which alter the storage key and the global state to register a new login state.</p>
<h2>Templates</h2>
<p>Okay, let's get into writing some views based on all this! We'll create an index page and an about page for demonstration, so set up a <code>src/templates/</code> directory with a <code>mod.rs</code> that declares both files. Then put the following in <code>src/templates/index.rs</code>:</p>
<pre><code class="language-rust">use crate::global_state::{AppStateRx, LoginState};
use perseus::{Html, Template};
use sycamore::prelude::*;

#[perseus::template_rx]
fn index_view(_: (), AppStateRx { auth }: AppStateRx) -&gt; View&lt;G&gt; {
    // This isn't part of our data model because it's only used here to pass to the login function
    let entered_username = Signal::new(String::new());
    let eu_2 = entered_username.clone();

    // We have to trigger this from outside the `create_memo`, and we should only be interacting with storage APIs in the browser (otherwise this would be called on the server too)
    // This will only cause a block on the first load, because this function just returns straight away if the state is already known
    #[cfg(target_arch = &quot;wasm32&quot;)]
    auth.detect_state();

    // We make the view as a memo outside the root `view!` for better editor support (some editors don't like highlighting code in macros)
    // We need to clone `global_state` because otherwise the `Signal` updates won't be registered
    let view = create_memo(cloned!(auth =&gt; move || {
        match *auth.state.get() {
            LoginState::Yes =&gt; {
                let username = auth.username.get();
                view! {
                    h1 { (format!(&quot;Welcome back, {}!&quot;, &amp;username)) }
                    button(on:click = cloned!(auth =&gt; move |_| {
                        auth.logout();
                    })) { &quot;Logout&quot; }
                }
            }
            // You could also redirect the user to a dedicated login page
            LoginState::No =&gt; view! {
                h1 { &quot;Welcome, stranger!&quot; }
                input(bind:value = entered_username.clone(), placeholder = &quot;Username&quot;)
                    button(on:click = cloned!(eu_2, auth =&gt; move |_| {
                        auth.login(&amp;eu_2.get())
                    })) { &quot;Login&quot; }
            },
            // This will appear for a few moments while we figure out if the user is logged in or not
            LoginState::Server =&gt; View::empty(),
        }
    }));
    view! {
        (*view.get())
        br()
        a(href = &quot;about&quot;) { &quot;About&quot; }
    }
}

pub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;index&quot;).template(index_view)
}

</code></pre>
<p>The only strange stuff in here is in <code>index_view()</code>, the rest is pretty much bog-standard Perseus template code. In <code>index_view()</code>, we don't take any template sttate, for demonstration purposes (you easily could), but we do take in the global state, which you'll remember contains all the authentication properties. Then we set up some <code>Signal</code>s outside the data model for handling a very simple login input (again, demonstrations). The important thing is the call to <code>auth.detect_state()</code>, which will refresh the authentication status by checking the user's browser for the login 'token' being stored. Note that, because we coded this to return straight away if we already know the login state, it's perfectly safe to put this at the start of every template you want to be authentication-protected. We also gate this with <code>#[cfg(target_arch = &quot;wasm32&quot;)]</code> to make sure it only runs on the browser (because we can't check for storage tokens in the server build process, that will throw plenty of errors!).</p>
<p>Skipping past the scary <code>let view = ...</code> block for a moment, the end of this function is dead simple: we just display a Sycamore <code>View&lt;G&gt;</code> stored in a <code>Signal</code> (that's in the <code>view</code> variable), and then a link to the about page. Anything other than that <code>(*view.get())</code> call will be displayed <em>whether the user is authenticated or not</em>.</p>
<p>Now for the fun part. To give us maximum editor support and cleanliness, we define the bulk of the view code outside the <code>view!</code> macro and in a variable called <code>view</code> instead, a derived <code>Signal</code> built with <code>create_memo</code> running on <code>auth.state</code>. So, if <code>auth.state</code> changes, this will also update immediately and automatically! All we do here is handle each of the three possible authentication states with a <code>match</code> statement: if we're on the server, we'll display nothing at all; if the user isn't logged in, a login page; and if they are, a welcome message and a logout button. In a real-world app, you'd probably have some code that redirects the user to a login page in the <code>LoginState::No</code> case.</p>
<p>You might be wondering why we display nothing before the login state is known, because this would seem to undercut the purpose of preloading the page at all. The answer to this question is that it does, and in an ideal world you'd process the user's login data on the server-side before serving them the appropriate prerendered page, which you <em>could</em> do, but that would be unnecessarily complex. Instead, we can display a blank page for a moment before redirecting or loading the appropriate skeleton.</p>
<p>In theory though, on some odler mobile devices, this blank screen might be visible for more than a moment (on 3G networks, it could be 2 seconds or more), which is not good at all. To remedy this, you could make <code>LoginState::Server</code> and <code>LoginState::Yes</code> render the same skeleton (with some blanks for unfetched user information), so you're essentially assuming the user to be logged in. That means only anonymous users get a flash, from the skeleton to a login page. If your login page is at a central route (e.g. <code>/login</code>), you could inject some JavaScript code to run before any of your page is rendered that would check if the user is logged in, and then redirect them to the login page before any of the page loaded if not. This is the best solution, which involves no flashing whatsoever, and the display time of your app is optimized for all users, without needing any server-side code!</p>
<p><em>Note: in future, there will likely be a plugin to perform this optimization automatically. If someone wants to create this now, please open a PR!</em></p>
<p>Finally, add the following into the about page (just a very basic unprotected page for comparison):</p>
<pre><code class="language-rust">use perseus::Template;
use sycamore::prelude::{view, Html, View};

#[perseus::template_rx]
pub fn about_page() -&gt; View&lt;G&gt; {
    view! {
        p { &quot;About.&quot; }
        a(href = &quot;&quot;) { &quot;Index&quot; }
    }
}

pub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {
    Template::new(&quot;about&quot;).template(about_page)
}

</code></pre>
<h2>Conclusion</h2>
<p>Authentication in Perseus is fairly easy to implement, easier than in many other frameworks, though there are a few hurdles to get over and patterns to understand that will make your code more idiomatic. In future, nearly all this will likely be handled automatically by a plugin or library, which would enable more rapid and efficient development of complex apps. For now though, authentication must be built manually into Perseus apps.</p>
</div></main></div></div></div></div><footer data-hk="1.25" class="w-full flex justify-center py-5 bg-gray-100 dark:bg-navy-deep"><p data-hk="1.26" class="dark:text-white mx-5 text-center"><span data-hk="1.27">© <a href="https://github.com/arctic-hen7" class="underline">arctic-hen7</a> ⁨2021⁩, see license <a href="https://github.com/arctic-hen7/perseus/blob/main/LICENSE" class="underline">here</a>.</span></p></footer><script data-hk="0.0" src=".perseus/static/prism.js" defer=""></script><script data-hk="0.1">window.Prism.highlightAll();</script></div></div></div></body></html>